
1. shell编程可以快速完成，适合构建简单任务的小工具。易于维护，具有高移植性。这点非常满足Unix哲学：Unix架构非常依赖于代码的高度可重用性！

2. 管道和重定向：

    ">": 重定向用来作用输入输出，尤其标准输入输出，即0，1，2三个文件。

        $ kill -l 1234 >/dev/null 2>&1  // 将kill命令结果标准输出到 null设备，即不显示在标准输出设备（屏幕）上， >& 符号表示标准错误设备同标准输出设备。

    ">>": 附加到文件末尾

    "<": 输入重定向
        $ more < killout.txt    // 将killout.txt内容作为more命令输入内容

    "|": 管道用于连接两个命令的输入输出。
        $ ps | sort | uniq | grep -v sh | more  // 将ps命令结果排序，去除重复数据，排除其中 sh进程，最后传给more命令

        注意管道中如果使用了文件，要注意不能使用同一个文件：
        $ cat mydata.txt | sort | uniq > mydata.txt 
        其中最后得到文件内容为空，在读取mydata.txt之前就已经覆盖了这个文件内容。即管道连接的多个命令中用到的文件可能被同时打开，所以不要在一个管道流中使用相同的文件名字。


3. 脚本

    脚本文件不一定非得“.sh”后缀结尾，可以使用file first 查看它是否是一个shell脚本。
    
    示例：
    ////////////////////////////////////////////
    #!/bin/sh

    # first
    # 在所有文件中查找POSIX字符，然后将文件名输出到
    # 标准输出设备

    for file in *
    do
        if grep -q POSIX $file
        then 
            echo $file
        fi
    done

    exit 0
    ////////////////////////////////////////////
    1. shell脚本以"#!/bin/sh"开始，用于指明解释程序，这个串最好不要超过32个字符，兼容老版本的Unix

    2. exit命令为脚本执行返回状态，它不是必须的，但是如果脚本需要被其他的脚本调用，则需要该命令，以便其他脚本可以知道调用结果
        "exit 0" 表示成功执行
    3.
正则表达式：

    "*": 
    "?": 
    "[abc]"
    "[^abc]":
    "{abc, elf}": 

grep: 

find: 
